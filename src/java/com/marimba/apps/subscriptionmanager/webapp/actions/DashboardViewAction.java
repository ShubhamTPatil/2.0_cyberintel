// Copyright 2019-2022, Harman International. All Rights Reserved.// Confidential and Proprietary Information of Harman International.// $File$, $Revision$, $Date$package com.marimba.apps.subscriptionmanager.webapp.actions;import com.marimba.apps.securitymgr.compliance.DashboardHandler;import com.marimba.apps.subscription.common.ISubscriptionConstants;import com.marimba.apps.subscription.common.intf.IUser;import com.marimba.apps.subscriptionmanager.beans.*;import com.marimba.apps.subscription.common.objects.Target;import com.marimba.apps.subscriptionmanager.intf.IWebAppConstants;import com.marimba.apps.subscriptionmanager.webapp.forms.NewDashboardViewForm;import com.marimba.apps.subscriptionmanager.webapp.util.DashboardUtil;import com.marimba.intf.application.IApplicationContext;import com.marimba.intf.msf.ITenant;import com.marimba.intf.util.IConfig;import com.marimba.tools.util.DebugFlag;import com.marimba.webapps.intf.IWebAppsConstants;import com.sun.jmx.snmp.tasks.Task;import org.apache.struts.action.ActionForm;import org.apache.struts.action.ActionForward;import org.apache.struts.action.ActionMapping;import com.marimba.tools.config.*;import com.marimba.intf.msf.*;import com.marimba.apps.subscriptionmanager.beans.TopVulnerableStatusBean;import com.marimba.intf.msf.IUserPrincipal;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.*;import java.util.*;/** * Dashboard View Action * w.r.t show new dashboard data * * @author Nandakumar Sankaralingam * @version: $Date$, $Revision$ */public class DashboardViewAction extends AbstractAction implements IWebAppConstants, ISubscriptionConstants {    public static int DEBUG = DebugFlag.getDebug("DEFENSIGHT/DASHBOARD");    protected Task createTask(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) {        return new DashboardViewAction.DashboardViewTask(mapping, form, request, response);    }    protected class DashboardViewTask extends SubscriptionDelayedTask {        NewDashboardViewForm dashboardForm;        ConfigProps config = null;        DashboardUtil dashboardUtil;        String runChannelDirPath = "";        String policyMgrChPath = "";        String tunerInstallDir = "";                              DashboardViewTask(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) {            super(mapping, form, request, response);            this.dashboardForm = (NewDashboardViewForm) form;        }        public void execute() {            init(request);            String action = request.getParameter("action");            action = dashboardForm.getAction();            dashboardUtil = new DashboardUtil();            try {                // initialize mitigate configuration                tunerInstallDir = tunerConfig.getProperty("runtime.workspace.dir");                File runChannelDir = new File(tunerInstallDir);                runChannelDir = new File(runChannelDir.getParent()).getCanonicalFile();                runChannelDir = new File(runChannelDir.getParent()).getCanonicalFile();                runChannelDirPath = runChannelDir.getAbsolutePath();                policyMgrChPath = fetchPolicyManagerChannelUrl();                if (isNull(policyMgrChPath)) {                    System.out.println("LogInfo: Please subscribe the Policy Manager channel on CMS tuner for DefenSight");                }                if (DEBUG >= 5) {                    System.out.println("DebugInfo: tunerInstallDir: " +tunerInstallDir);                    System.out.println("DebugInfo: runChannelDir path: "+runChannelDirPath);                    System.out.println("DebugInfo: policyMgrChPath path: "+ policyMgrChPath);                }                String cmsUser = request.getUserPrincipal().getName();                String cmsPwd = tunerConfig.getProperty("marimba.cmsuser.password");                initMitigateConfig();                DashboardHandler dashboardHandler = new DashboardHandler(main);                if (null == action || "view".equals(action)) {                    int totalMachineCount = dashboardHandler.getEnrolledMachines("all");                    int totalWindowsMachineCount = dashboardHandler.getEnrolledMachinesByOS("Windows");                    int totalLinuxMachineCount = dashboardHandler.getEnrolledMachinesByOS("Linux");                    int totalMacMachineCount = dashboardHandler.getEnrolledMachinesByOS("MAC");                    // Scanned Machines Count                    int vScanMachinesCount = dashboardHandler.getVScanMachinesCount("vscan");                    int patchScanMachinesCount = dashboardHandler.getPatchScanMachinesCount("patchscan");                    Map<String, String> vulnerableStatsInfo = dashboardHandler.getVulnerableStatsInfo();                    String critical = isNull(vulnerableStatsInfo.get("Critical")) ? "0" : vulnerableStatsInfo.get("Critical");                    String high = isNull(vulnerableStatsInfo.get("High")) ? "0" : vulnerableStatsInfo.get("High");                    String medium = isNull(vulnerableStatsInfo.get("Medium")) ? "0" : vulnerableStatsInfo.get("Medium");                    String low = isNull(vulnerableStatsInfo.get("Low")) ? "0" : vulnerableStatsInfo.get("Low");                    String pieChartDataSet = "[" + critical + "," + high + "," + medium + "," + low + "]";                    long totalVul = Long.parseLong(critical) + Long.parseLong(high) + Long.parseLong(medium) + Long.parseLong(low);                    VulnerableStatusBean vsbean = new VulnerableStatusBean();                    vsbean.setCritical(critical);                    vsbean.setHigh(high);                    vsbean.setMedium(medium);                    vsbean.setLow(low);                    dashboardForm.setMachinesCount(String.valueOf(totalMachineCount));                    dashboardForm.setMachineWindowsCount(String.valueOf(totalWindowsMachineCount));                    dashboardForm.setMachineLinuxCount(String.valueOf(totalLinuxMachineCount));                    dashboardForm.setMachineMacCount(String.valueOf(totalMacMachineCount));                    dashboardForm.setVscanCount(String.valueOf(vScanMachinesCount));                    dashboardForm.setPatchScanCount(String.valueOf(patchScanMachinesCount));                    dashboardForm.setPieChartData(pieChartDataSet);                    dashboardForm.setVulnerableStatusBean(vsbean);                    dashboardForm.setTotalVulnerable(String.valueOf(totalVul));                    /*                    List<TopVulnerableStatusBean> topVulList = dashboardHandler.getTopVulnerabilitiesInfo();                    dashboardForm.setTopVulnerableList(topVulList);                    String topVulnsJson = dashboardUtil.makeTopVulnerabilitiesJsonData(topVulList);                    dashboardForm.setTopVulnerableData(topVulnsJson);                    */                    Map<String, String> reportingResult = dashboardHandler.getComplianceType("reporting");                    Map<String, String> securityResult = dashboardHandler.getComplianceType("security");                    Map<String, String> patchResult = dashboardHandler.getComplianceType("patch");                    dashboardForm.setReportingCheckedIn(reportingResult.get("checkedIn"));                    dashboardForm.setReportingNotCheckedIn(reportingResult.get("notCheckedIn"));                    dashboardForm.setSecurityCompliant(securityResult.get("compliant"));                    dashboardForm.setSecurityNonCompliant(securityResult.get("nonCompliant"));                    dashboardForm.setPatchCompliant(patchResult.get("compliant"));                    dashboardForm.setPatchNonCompliant(patchResult.get("nonCompliant"));                    Map<String, String> vulSeverityInfo = dashboardHandler.getAgingVulnerableBySeverityWise();                    String vulSeverityInfoJson = dashboardUtil.makeVulnerableSeverityJsonData(vulSeverityInfo);                    dashboardForm.setVulnerableSeverityData(vulSeverityInfoJson);                    List<PriorityPatchesBean> prtyPatchesList = dashboardHandler.getPriorityPatchesInfo();                    dashboardForm.setPriorityPatchesList(prtyPatchesList);                    String prtyPatchesJson = dashboardUtil.makePriorityPatchesJsonData(prtyPatchesList);                    dashboardForm.setPriorityPatchesData(prtyPatchesJson);                    forward = mapping.findForward("view");                } else if ("notcheckedin_info".equalsIgnoreCase(action)) {                    List<ReportingNotCheckedInBean> rptNotCheckedInList = dashboardHandler.getComplianceReportNotCheckedIn();                    dashboardForm.setRptNotCheckedInList(rptNotCheckedInList);                    String rptNotCheckedInJson = dashboardUtil.makeReportingNotCheckedInJsonData(rptNotCheckedInList);                    dashboardForm.setReportNotCheckedInData(rptNotCheckedInJson);                    sendJSONResponse(response, rptNotCheckedInJson);                    forward = mapping.findForward("view");                } else if ("mitigate".equalsIgnoreCase(action)) {                    String patchids = request.getParameter("patchids");                    String[] repIDs = patchids.split(",");                    StringBuffer sb = new StringBuffer();                    for (int i = 0; i < repIDs.length; i++) {                        sb.append("'");                        sb.append(repIDs[i]);                        sb.append("'");                        if (i == (repIDs.length - 1)) {                            break;                        } else {                            sb.append(",");                        }                    }                    List<MitigatePatchesBean> mitigatePatchesList = dashboardHandler.getMitigatePatchesInfo(sb.toString());                    String mitigatePatchesJson = dashboardUtil.makeMitigatePatchesJsonData(mitigatePatchesList);                    sendJSONResponse(response, mitigatePatchesJson);                    forward = mapping.findForward("view");                } else if ("apply_patches".equalsIgnoreCase(action)) {                    String machinePatchgrps = request.getParameter("machinepatchgroups");                    String[] patchGroupList = machinePatchgrps.split(",");                    List<String> machinesList = new ArrayList<String>(Arrays.asList(patchGroupList));                    initMitigateConfig();                    ConfigProps config = getMitigateConfig();                    if (config != null) {                        String masterTx = config.getProperty("mastertx.url");                        String policyMgrUrl = config.getProperty("policymanager.channel.url");                        String runchannelDir = config.getProperty("tunerworkspace.runchannelexe.location");                        Map<String, String> patchDeployResult = dashboardUtil.executeMitigateCLI(machinesList, policyMgrUrl, masterTx, runchannelDir, cmsUser, cmsPwd);                        String patchDeployResultJSON = dashboardUtil.makeMitigateResultJSON(patchDeployResult);                        if (DEBUG >= 5) {                            System.out.println("DebugInfo: apply_patches::patchDeployResultJSON: "+patchDeployResultJSON);                        }                        sendJSONResponse(response, patchDeployResultJSON);                    }                } else if ("patch_applied".equalsIgnoreCase(action) || "patch_notapplied".equalsIgnoreCase(action)                        || "patch_notscanned".equalsIgnoreCase(action)) {                    List<PatchComplianceStatusBean> pcsInfoList = dashboardHandler.getPatchComplianceStatusInfo(action);                    dashboardForm.setPatchComplianceStatusList(pcsInfoList);                }            } catch (Exception ex) {                ex.printStackTrace();            }        }        private ConfigProps getMitigateConfig() {            return config;        }        private String fetchPolicyManagerChannelUrl() throws Exception {            String policyMgrChUrl = "";            File mapTxt = new File(tunerInstallDir, "map.txt");            if (mapTxt.exists()) {                BufferedReader bufferedreader = new BufferedReader(new FileReader(mapTxt));                String strLine;                do {                    strLine = bufferedreader.readLine();                    if (strLine == null) {                        break;                    }                } while (!strLine.contains("SubscriptionManager"));                if (!isNull(strLine)) {                    strLine= strLine.substring(0, strLine.indexOf("="));                    policyMgrChUrl = strLine;                   // System.out.println("DebugInfo: PolicyMgrChUrl==> " + policyMgrChUrl);                }            }            return policyMgrChUrl;        }        private void initMitigateConfig() {            File rootDir = main.getDataDirectory();            if (rootDir != null && rootDir.isDirectory()) {                File configFile = new File(rootDir, "mitigate_config.txt");                try {                    if (!configFile.exists()) {                        config = new ConfigProps(configFile);                        config.setProperty("mastertx.url", "http://localhost:5282");                        config.setProperty("policymanager.channel.url", policyMgrChPath);                        config.setProperty("tunerworkspace.runchannelexe.location", runChannelDirPath);                        if (!config.save()) {                            throw new Exception("Failed to save mitigate configurations");                        }                        config.close();                    } else {                        config = new ConfigProps(configFile);                        config.setProperty("policymanager.channel.url", policyMgrChPath);                        config.setProperty("tunerworkspace.runchannelexe.location", runChannelDirPath);                        config.save();                    }                } catch (Exception ioe) {                    ioe.printStackTrace();                    config = null;                }            }        }        protected void sendJSONResponse(HttpServletResponse response, String jsonData) throws Exception {            PrintWriter out = response.getWriter();            out.println(jsonData);            out.flush();        }        public String getWaitMessage() {            return getString("page.global.processing");        }    }}