package com.marimba.apps.subscriptionmanager.webapp.util.defensight;import com.azure.cosmos.CosmosClient;import com.azure.cosmos.CosmosClientBuilder;import com.azure.cosmos.CosmosContainer;import com.azure.cosmos.CosmosDatabase;import com.azure.cosmos.models.CosmosQueryRequestOptions;import com.azure.cosmos.models.PartitionKey;import com.azure.cosmos.models.SqlParameter;import com.azure.cosmos.models.SqlQuerySpec;import com.azure.cosmos.util.CosmosPagedIterable;import com.marimba.intf.util.IConfig;import com.marimba.tools.util.DebugFlag;import com.marimba.apps.subscriptionmanager.webapp.util.defensight.AnomalyConstants.Queries;import java.time.Clock;import java.time.Duration;import java.time.OffsetDateTime;import java.util.*;import java.util.concurrent.atomic.AtomicInteger;import java.util.stream.Collectors;public class AnomalyUtil {  public static final int DEBUG = DebugFlag.getDebug("DEFENSIGHT/ACTION");  private static CosmosClient client = null;  private static CosmosDatabase database = null;  private static CosmosContainer container = null;  /**   * Runnable to get run the getCosmosConnection method. Will get called from the DefenSight   * dashboard action NewDashboardAction.java To keep the connection ready before landing on   * analytics page   *   * @param tunerConfig   * @return Runnable   */  public static Runnable getCosmosConectionRunnable(IConfig tunerConfig) {    return () -> {      System.out.println("Lambda Runnable running");      AnomalyUtil.getCosmosConnection(tunerConfig);      System.out.println("Lambda Runnable stopped");    };  }  /**   * Make the connection with Azure Cosmos DB Currently getting called from runnable only   *   * @param config tunerConfig   */  private static synchronized void getCosmosConnection(IConfig config) {    String containerName = config.getProperty(AnomalyConstants.CONTAINER_NAME);    String databaseName = config.getProperty(AnomalyConstants.DATABASE_NAME);    String host = config.getProperty(AnomalyConstants.HOST);    String key = config.getProperty(AnomalyConstants.KEY);    if (container == null) {      try {        client = new CosmosClientBuilder().endpoint(host).key(key).buildClient();        System.out.println("getCosmosConnection(): connection established successfully ");        CosmosDatabase database = client.getDatabase(databaseName);        container = database.getContainer(containerName);      } catch (Exception e) {        System.out.println("getCosmosConnection(): connection failed "+e.getMessage());        e.printStackTrace();      }    } else {      String query = "SELECT TOP 1 c.event.created FROM c"; // Change the query as needed      CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();      CosmosPagedIterable<CosmosConnectionCheck> queryResults = container.queryItems(query, options, CosmosConnectionCheck.class);      if (!queryResults.iterator().hasNext()) {        System.out.println("Cosmos DB is not alive.");        try {          client = new CosmosClientBuilder().endpoint(host).key(key).buildClient();          System.out.println("getCosmosConnection(): connection established successfully ");          CosmosDatabase database = client.getDatabase(databaseName);          container = database.getContainer(containerName);        } catch (Exception e) {          System.out.println("getCosmosConnection(): connection failed "+e.getMessage());          e.printStackTrace();        }      } else {        System.out.println("Cosmos DB is alive.");      }    }/*    if (container == null) {      try {        CosmosClient client = new CosmosClientBuilder().endpoint(host).key(key).buildClient();        System.out.println("getCosmosConnection(): connection established successfully ");        CosmosDatabase database = client.getDatabase(databaseName);        container = database.getContainer(containerName);      } catch (Exception e) {        System.out.println("getCosmosConnection(): connection failed ");        e.printStackTrace();      }    } */  }  /**   * Populate the data for Top Level Statistics chart   * @param tunerConfig   * @param currentTime   * @param prevTime   * @return   */  public List<TopLevelStatsChartData> populateTopLevelStatsData(IConfig tunerConfig, OffsetDateTime currentTime, OffsetDateTime prevTime) {    System.out.println("populateTopLevelStatsData query:\n SELECT c.host.hostname as hostname, c.predictions as anomaly, c.event.created as time FROM c  WHERE c.event.created <= '"+currentTime.toString()+"' AND c.event.created >= '"+prevTime.toString()+"' AND c.host.hostname != null AND c.predictions != null AND c.event.created != null");    getCosmosConnection(tunerConfig);    CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();    options.setPartitionKey(new PartitionKey(AnomalyConstants.PARTITION_KEY));    ArrayList<SqlParameter> paramList = new ArrayList<SqlParameter>();    paramList.add(new SqlParameter("@ctime", currentTime.toString()));    paramList.add(new SqlParameter("@ptime", prevTime.toString()));    CosmosPagedIterable<TopLevelStatsChartData> topLevelStatsChartDataList =        executeQueryForTopLevelStats(new SqlQuerySpec(Queries.SCATTER_CHART_QUERY, paramList));    return topLevelStatsDataPoints(topLevelStatsChartDataList, currentTime, prevTime);  }  public CosmosPagedIterable<MachineLevelAnomalyRatio> populateMachineLevelAnomaly(      IConfig tunerConfig, String hostname, OffsetDateTime currentTime, OffsetDateTime prevTime) {    getCosmosConnection(tunerConfig);    CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();    /*    String machineWithHighestAnomaly = "";    List<MachineAnomalyCount> results = null;    Iterable<FeedResponse<MachineAnomalyCount>> hostnameAndPredictionsCount =        container            .queryItems(Queries.FETCH_HOSTNAMEANDPREDICTIONS, options, MachineAnomalyCount.class)            .iterableByPage();    if (hostnameAndPredictionsCount == null) {      return null;    }    for (FeedResponse<MachineAnomalyCount> feedResponse : hostnameAndPredictionsCount) {      results = feedResponse.getResults();    }    Optional<MachineAnomalyCount> maxPredictions =        results.stream().max(Comparator.comparingInt(MachineAnomalyCount::getAnomaliesCount));    if (maxPredictions.isPresent()) {      MachineAnomalyCount maxObject = maxPredictions.get();      machineWithHighestAnomaly = maxObject.getHostname();    } else {      return null;    }     */    if(hostname == null) {      hostname = fetchMachineNameList(tunerConfig, getCurrentAndPrevTime(720).get(1)).iterator().next().getHostname();    }    System.out.println("populateMachineLevelAnomaly query: \n SELECT c.winlog.event_id as event_id, c.predictions as anomaly, c.event.created as time FROM c  WHERE c.event.created <= '"+currentTime.toString()+"' AND c.event.created >= '"+prevTime.toString()+"' AND c.host.hostname = '"+hostname+"' AND c.predictions = 'true' AND c.event.created != null AND c.winlog.event_id != null");    options.setPartitionKey(new PartitionKey(AnomalyConstants.PARTITION_KEY));    ArrayList<SqlParameter> paramList = new ArrayList<SqlParameter>();    paramList.add(new SqlParameter("@ctime", currentTime.toString()));    paramList.add(new SqlParameter("@ptime", prevTime.toString()));    paramList.add(new SqlParameter("@hostname", hostname));    return executeQueryForMachineLevelAnomalyRatio(            new SqlQuerySpec(Queries.MACHINE_LEVEL_ANOMALY, paramList));  }  public CosmosPagedIterable<MachineNameList> fetchMachineNameList(IConfig tunerConfig, OffsetDateTime prevTime) {    ArrayList<SqlParameter> paramList = new ArrayList<SqlParameter>();    paramList.add(new SqlParameter("@ptime", prevTime.toString()));    System.out.println("fetchMachineNameList query: \n select distinct c.host.hostname as hostname from c where c.host.hostname != null AND c.event.created >= '"+prevTime.toString()+"'");    getCosmosConnection(tunerConfig);    return executeQueryForMachineNameList(new SqlQuerySpec(Queries.MACHINE_NAME_LIST, paramList));  }  /**   * Generates 60 data points to plot the graph for Top Level Stats   *   * @param topLevelStatsChartDataList List of TopLevelStatsChartData   * @param currentTime Current Time in OffsetDateTime format   * @param endTime End Time in OffsetDateTime format   * @return Result List of TopLevelStatsChartData   */  private List<TopLevelStatsChartData> topLevelStatsDataPoints(          CosmosPagedIterable<TopLevelStatsChartData> topLevelStatsChartDataList,          OffsetDateTime currentTime,          OffsetDateTime endTime) {    HashMap<OffsetDateTime, OffsetDateTime> timeIntervals =        createEqualSixtyTimeIntervals(endTime, currentTime);    Map<String, List<TopLevelStatsChartData>> anomalyScatterChartMap =        topLevelStatsChartDataList.stream()            .map(r -> new TopLevelStatsChartData(r.getHostname(), r.getTime(), r.getAnomaly()))            .collect(Collectors.groupingBy(TopLevelStatsChartData::getHostname));    List<TopLevelStatsChartData> topLevelStatsResultList = new ArrayList<>();    anomalyScatterChartMap.forEach(        (hostname, list) -> {          timeIntervals.forEach(              (start, end) -> {                TopLevelStatsChartData resultChartData =                    new TopLevelStatsChartData(hostname, end.toString(), "false");                for (TopLevelStatsChartData anomalyChartData : list) {                  if (start.isBefore(OffsetDateTime.parse(anomalyChartData.getTime()))                      && end.isAfter(OffsetDateTime.parse(anomalyChartData.getTime()))) {                    if (anomalyChartData.getAnomaly().equals("Not_Trained")) {                      resultChartData.setAnomaly("Not_Trained");                      break;                    }                    if (anomalyChartData.getAnomaly().equals("true")) {                      resultChartData.setAnomaly("true");                      break;                    }                  }                }                topLevelStatsResultList.add(resultChartData);              });        });    return topLevelStatsResultList;  }  /**   * Execute query for Top Level Statistics Chart   *   * @param querySpec Query with Parameters   * @return List of TopLevelStatsChartData   */  private CosmosPagedIterable<TopLevelStatsChartData> executeQueryForTopLevelStats(SqlQuerySpec querySpec) {    CosmosPagedIterable<TopLevelStatsChartData> filterUserRecords =        container.queryItems(            querySpec, new CosmosQueryRequestOptions(), TopLevelStatsChartData.class);    AtomicInteger count = new AtomicInteger();    filterUserRecords.stream().forEach(topLevelStatsChartData -> {      count.getAndIncrement();    });    System.out.println("executeQueryForTopLevelStats count = "+count);    return filterUserRecords;  }  private CosmosPagedIterable<MachineNameList> executeQueryForMachineNameList(SqlQuerySpec querySpec) {      return container.queryItems(querySpec, new CosmosQueryRequestOptions(), MachineNameList.class);  }  private CosmosPagedIterable<MachineLevelAnomalyRatio> executeQueryForMachineLevelAnomalyRatio(      SqlQuerySpec querySpec) {    CosmosPagedIterable<MachineLevelAnomalyRatio> filterUserRecords =        container.queryItems(            querySpec, new CosmosQueryRequestOptions(), MachineLevelAnomalyRatio.class);    return filterUserRecords;  }  /**   * Generates equal intervals between startTime and endTime startTime should be before endTime   *   * @param startTime latest time   * @param endTime last time   * @return map of intervals   */  public static HashMap<OffsetDateTime, OffsetDateTime> createEqualSixtyTimeIntervals(      OffsetDateTime startTime, OffsetDateTime endTime) {    // Check if the endTime is before the startTime    if (endTime.isBefore(startTime)) {      throw new IllegalArgumentException("endTime cannot be before startTime");    }    HashMap<OffsetDateTime, OffsetDateTime> timeIntervals = new HashMap<>();    OffsetDateTime currentStart = startTime;    OffsetDateTime currentEnd;    // Calculate the total duration between startTime and endTime    Duration totalDuration = Duration.between(startTime, endTime);    // Calculate the interval size based on the total duration    long intervalSeconds = totalDuration.getSeconds() / 60; // 60 seconds per minute    while (currentStart.isBefore(endTime)) {      currentEnd = currentStart.plusSeconds(intervalSeconds);      // Ensure the currentEnd doesn't go beyond the endTime      if (currentEnd.isAfter(endTime)) {        currentEnd = endTime;      }      timeIntervals.put(currentStart, currentEnd);      currentStart = currentEnd;    }    return timeIntervals;  }  public List<OffsetDateTime> getCurrentAndPrevTime(int minutes) {    OffsetDateTime currentTime = OffsetDateTime.now(Clock.systemUTC()).minusMinutes(1);    OffsetDateTime prevTime = currentTime.minusMinutes(minutes);    List<OffsetDateTime> list = new ArrayList<>();    list.add(currentTime);    list.add(prevTime);    return list;  }  private void debugInfo(String msg) {    if (DEBUG >= 5) System.out.println("DEBUG:AnomalyAction : " + msg);  }  private void log(String msg) {    if (DEBUG >= 3) System.out.println("LogInfo:AnomalyAction : " + msg);  }}