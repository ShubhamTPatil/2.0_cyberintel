package com.marimba.apps.subscriptionmanager.webapp.util.defensight;import com.azure.cosmos.CosmosClient;import com.azure.cosmos.CosmosClientBuilder;import com.azure.cosmos.CosmosContainer;import com.azure.cosmos.CosmosDatabase;import com.azure.cosmos.models.CosmosQueryRequestOptions;import com.azure.cosmos.models.FeedResponse;import com.azure.cosmos.models.PartitionKey;import com.azure.cosmos.models.SqlParameter;import com.azure.cosmos.models.SqlQuerySpec;import com.azure.cosmos.util.CosmosPagedIterable;import com.fasterxml.jackson.databind.ObjectMapper;import com.marimba.intf.util.IConfig;import com.marimba.tools.util.DebugFlag;import com.marimba.apps.subscriptionmanager.webapp.util.defensight.AnomalyConstants.Queries;import com.marimba.apps.subscriptionmanager.webapp.util.defensight.MachineAnomalyCount;import com.marimba.apps.subscriptionmanager.webapp.util.defensight.MachineLevelAnomalyRatio;import java.time.Clock;import java.time.Duration;import java.time.OffsetDateTime;import java.util.*;import java.util.stream.Collectors;public class AnomalyUtil {  public static final int DEBUG = DebugFlag.getDebug("DEFENSIGHT/ACTION");  private static CosmosContainer container = null;  /**   * Runnable to get run the getCosmosConnection method. Will get called from the DefenSight   * dashboard action NewDashboardAction.java To keep the connection ready before landing on   * analytics page   *   * @param tunerConfig   * @return Runnable   */  public static Runnable getCosmosConectionRunnable(IConfig tunerConfig) {    return () -> {      System.out.println("Lambda Runnable running");      AnomalyUtil.getCosmosConnection(tunerConfig);      System.out.println("Lambda Runnable stopped");    };  }  /**   * Make the connection with Azure Cosmos DB Currently getting called from runnable only   *   * @param config tunerConfig   */  private static synchronized void getCosmosConnection(IConfig config) {    String containerName = config.getProperty(AnomalyConstants.CONTAINER_NAME);    String databaseName = config.getProperty(AnomalyConstants.DATABASE_NAME);    String host = config.getProperty(AnomalyConstants.HOST);    String key = config.getProperty(AnomalyConstants.KEY);    if (container == null) {      try {        CosmosClient client = new CosmosClientBuilder().endpoint(host).key(key).buildClient();        System.out.println("getCosmosConnection(): connection established successfully ");        CosmosDatabase database = client.getDatabase(databaseName);        container = database.getContainer(containerName);      } catch (Exception e) {        System.out.println("getCosmosConnection(): connection failed ");        e.printStackTrace();      }    }  }  /**   * Populate the data for Top Level Statistics chart   *   * @param tunerConfig   * @param minutes For which data is required   * @return List of TopLevelStatsChartData   */  public List<TopLevelStatsChartData> populateTopLevelStatsData(IConfig tunerConfig, int minutes) {    getCosmosConnection(tunerConfig);    CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();    options.setPartitionKey(new PartitionKey(AnomalyConstants.PARTITION_KEY));    ArrayList<SqlParameter> paramList = new ArrayList<SqlParameter>();    OffsetDateTime currentTime = OffsetDateTime.now(Clock.systemUTC());    OffsetDateTime endTime = getEndTime(minutes);    paramList.add(new SqlParameter("@ctime", currentTime.toString()));    paramList.add(new SqlParameter("@ptime", endTime.toString()));    List<TopLevelStatsChartData> topLevelStatsChartDataList =        executeQueryForTopLevelStats(new SqlQuerySpec(Queries.SCATTER_CHART_QUERY, paramList));    return topLevelStatsDataPoints(topLevelStatsChartDataList, currentTime, endTime);  }  // PieChart1  public List<MachineLevelAnomalyRatio> populateMachinelevelAnomalyRatio(      IConfig tunerConfig, int minutes) {    getCosmosConnection(tunerConfig);    String machineWithHighestAnomaly = "";    List<MachineAnomalyCount> results = null;    CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();    Iterable<FeedResponse<MachineAnomalyCount>> hostnameAndPredictionsCount =        container            .queryItems(Queries.FETCH_HOSTNAMEANDPREDICTIONS, options, MachineAnomalyCount.class)            .iterableByPage();    if (hostnameAndPredictionsCount == null) {      return null;    }    for (FeedResponse<MachineAnomalyCount> feedResponse : hostnameAndPredictionsCount) {      results = feedResponse.getResults();    }    Optional<MachineAnomalyCount> maxPredictions =        results.stream().max(Comparator.comparingInt(MachineAnomalyCount::getAnomaliesCount));    if (maxPredictions.isPresent()) {      MachineAnomalyCount maxObject = maxPredictions.get();      machineWithHighestAnomaly = maxObject.getHostname();    } else {      return null;    }    options.setPartitionKey(new PartitionKey(AnomalyConstants.PARTITION_KEY));    ArrayList<SqlParameter> paramList = new ArrayList<SqlParameter>();    OffsetDateTime currentTime = OffsetDateTime.now(Clock.systemUTC());    OffsetDateTime endTime = getEndTime(minutes);    paramList.add(new SqlParameter("@ctime", currentTime.toString()));    paramList.add(new SqlParameter("@ptime", endTime.toString()));    paramList.add(new SqlParameter("@hostname", machineWithHighestAnomaly.toString()));    List<com.marimba.apps.subscriptionmanager.webapp.util.defensight.MachineLevelAnomalyRatio>        machineLevelAnomalyDataList =            executeQueryForMachineLevelAnomalyRatio(                new SqlQuerySpec(Queries.MACHINE_LEVEL_ANOMALY_PIECHART, paramList));    return machineLevelAnomalyDataList;  }  /**   * Generates 60 data points to plot the graph for Top Level Stats   *   * @param topLevelStatsChartDataList List of TopLevelStatsChartData   * @param currentTime Current Time in OffsetDateTime format   * @param endTime End Time in OffsetDateTime format   * @return Result List of TopLevelStatsChartData   */  private List<TopLevelStatsChartData> topLevelStatsDataPoints(      List<TopLevelStatsChartData> topLevelStatsChartDataList,      OffsetDateTime currentTime,      OffsetDateTime endTime) {    HashMap<OffsetDateTime, OffsetDateTime> timeIntervals =        createEqualSixtyTimeIntervals(endTime, currentTime);    Map<String, List<TopLevelStatsChartData>> anomalyScatterChartMap =        topLevelStatsChartDataList.stream()            .map(r -> new TopLevelStatsChartData(r.getHostname(), r.getTime(), r.getAnomaly()))            .collect(Collectors.groupingBy(TopLevelStatsChartData::getHostname));    List<TopLevelStatsChartData> topLevelStatsResultList = new ArrayList<>();    anomalyScatterChartMap.forEach(        (hostname, list) -> {          timeIntervals.forEach(              (start, end) -> {                TopLevelStatsChartData resultChartData =                    new TopLevelStatsChartData(hostname, end.toString(), "false");                for (TopLevelStatsChartData anomalyChartData : list) {                  if (start.isBefore(OffsetDateTime.parse(anomalyChartData.getTime()))                      && end.isAfter(OffsetDateTime.parse(anomalyChartData.getTime()))) {                    if (anomalyChartData.getAnomaly().equals("Not_Trained")) {                      resultChartData.setAnomaly("Not_Trained");                      break;                    }                    if (anomalyChartData.getAnomaly().equals("true")) {                      resultChartData.setAnomaly("true");                      break;                    }                  }                }                topLevelStatsResultList.add(resultChartData);              });        });    return topLevelStatsResultList;  }  /**   * Execute query for Top Level Statistics Chart   *   * @param querySpec Query with Parameters   * @return List of TopLevelStatsChartData   */  private List<TopLevelStatsChartData> executeQueryForTopLevelStats(SqlQuerySpec querySpec) {    CosmosPagedIterable<TopLevelStatsChartData> filterUserRecords =        container.queryItems(            querySpec, new CosmosQueryRequestOptions(), TopLevelStatsChartData.class);    // TODO : Need to check if we can directly use CosmosPagedIterable instead of List to save the    // iteration.    return filterUserRecords.stream()        .limit(5000) // TODO : remove this limit and set it from query level        .collect(Collectors.toList());  }  private List<com.marimba.apps.subscriptionmanager.webapp.util.defensight.MachineLevelAnomalyRatio>      executeQueryForMachineLevelAnomalyRatio(SqlQuerySpec querySpec) {    CosmosPagedIterable<            com.marimba.apps.subscriptionmanager.webapp.util.defensight.MachineLevelAnomalyRatio>        filterUserRecords =            container.queryItems(                querySpec,                new CosmosQueryRequestOptions(),                com.marimba.apps.subscriptionmanager.webapp.util.defensight.MachineLevelAnomalyRatio                    .class);    // TODO : Need to check if we can directly use CosmosPagedIterable instead of List to save the    // iteration.    return filterUserRecords.stream()        .limit(5000) // TODO : remove this limit and set it from query level        .collect(Collectors.toList());  }  /**   * @param minutes in integer   * @return current time minus minutes in OffsetDateTime format   */  private OffsetDateTime getEndTime(int minutes) {    return OffsetDateTime.now(Clock.systemUTC()).minusMinutes(minutes);  }  /**   * Generates equal intervals between startTime and endTime startTime should be before endTime   *   * @param startTime latest time   * @param endTime last time   * @return map of intervals   */  public static HashMap<OffsetDateTime, OffsetDateTime> createEqualSixtyTimeIntervals(      OffsetDateTime startTime, OffsetDateTime endTime) {    // Check if the endTime is before the startTime    if (endTime.isBefore(startTime)) {      throw new IllegalArgumentException("endTime cannot be before startTime");    }    HashMap<OffsetDateTime, OffsetDateTime> timeIntervals = new HashMap<>();    OffsetDateTime currentStart = startTime;    OffsetDateTime currentEnd;    // Calculate the total duration between startTime and endTime    Duration totalDuration = Duration.between(startTime, endTime);    // Calculate the interval size based on the total duration    long intervalSeconds = totalDuration.getSeconds() / 60; // 60 seconds per minute    while (currentStart.isBefore(endTime)) {      currentEnd = currentStart.plusSeconds(intervalSeconds);      // Ensure the currentEnd doesn't go beyond the endTime      if (currentEnd.isAfter(endTime)) {        currentEnd = endTime;      }      timeIntervals.put(currentStart, currentEnd);      currentStart = currentEnd;    }    return timeIntervals;  }  private void debugInfo(String msg) {    if (DEBUG >= 5) System.out.println("DEBUG:AnomalyAction : " + msg);  }  private void log(String msg) {    if (DEBUG >= 3) System.out.println("LogInfo:AnomalyAction : " + msg);  }}